def get_distance(self, current, end_point): #this is only the manhatten distance
  distance = math.sqrt(abs(current[0] - end_point[0]) ** 2 + abs(current[1] - end_point[1]) ** 2 + abs(
  current[2] - end_point[2]) ** 2)
  return distance
def get_distance_angles(self, current, end_point):
   distance = math.sqrt(2) * abs(current[0] - end_point[0]) + abs(current[1] - end_point[1]) + abs(current[2] - end_point[2])
   return distance
def get_distance_top_corners(self, current, end_point):
   distance = math.sqrt(3) * abs(current[0] - end_point[0]) + abs(current[1] - end_point[1]) + abs(current[2] - end_point[2])
   return distance
                    
                    
if (current[0] + 1) == neighbors or (current[0] - 1) == neighbors or (current[1] + 1) == neighbors or (current[1] - 1) == neighbors or (current[2] + 1) == neighbors or (current[2] - 1) == neighbors:
  priority = new_cost + self.get_distance(next, self.end_point)
  frontier.put(next, priority)
  came_from[next] = current
if (current[0] + 1) + (current[1] + 1) == neighbors or (current[0] - 1) + (current[1] + 1) == neighbors or (current[0] + 1) + (current[1] - 1) == neighbors or (current[0] - 1) + (current[1] - 1) == neighbors or (current[0] + 1) + (current[2] + 1) == neighbors or (current[0] - 1) + (current[2] + 1) == neighbors or (current[0] + 1) + (current[2] - 1) == neighbors or (current[0] - 1) + (current[2] - 1) == neighbors or (current[1] + 1) + (current[2] + 1) == neighbors or (current[1] - 1) + (current[2] + 1) == neighbors or (current[1] + 1) + (current[2] - 1) == neighbors or (current[1] - 1) + (current[2] - 1) == neighbors:
  priority = new_cost + self.get_distance_angles(next, self.end_point)
  frontier.put(next, priority)
  came_from[next] = current
if (current[0] + 1) + (current[1] + 1) + (current[2] + 1) == neighbors or (current[0] - 1) + (current[1] + 1) + (current[2] + 1) == neighbors or (current[0] + 1) + (current[1] - 1) + (current[2] + 1) == neighbors or (current[0] - 1) + (current[1] - 1) + (current[2] + 1) == neighbors or (current[0] + 1) + (current[1] + 1) + (current[2] - 1) == neighbors or (current[0] - 1) + (current[1] + 1) + (current[2] - 1) == neighbors or (current[0] + 1) + (current[1] - 1) + (current[2] - 1) == neighbors or (current[0] - 1) + (current[1] - 1) + (current[2] - 1) == neighbors:
  priority = new_cost + self.get_distance_top_corners(next, self.end_point)
  frontier.put(next, priority)
  came_from[next] = current
